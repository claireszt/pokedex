"use strict";Object.defineProperties(exports,{t:{value:!0},[Symbol.toStringTag]:{value:"Module"}});class t{constructor(t,s,r,e=t<<16|s<<8|r){this.i=1,this.o=-1,this.h=-1,this.u=-1,this.l=-1,this.M=t,this.g=s,this.$=r,this.p=e}static distance(t,s){return(Math.abs(s.M-t.M)+Math.abs(s.g-t.g)+Math.abs(s.$-t.$))/765}clone(){const s=new t(this.M,this.g,this.$,this.p);return s.i=this.i,s}m(){const t=this.M/255,s=this.g/255,r=this.$/255,e=Math.max(t,s,r),i=Math.min(t,s,r);if(this.u=(e+i)/2,e===i)this.h=0,this.o=0,this.l=0;else{const o=e-i;switch(this.o=this.u>.5?o/(2-e-i):o/(e+i),this.l=this.o*(2*(.5-Math.abs(.5-this.u))),e){case t:this.h=((s-r)/o+(s<r?6:0))/6;break;case s:this.h=((r-t)/o+2)/6;break;case r:this.h=((t-s)/o+4)/6}}}get C(){return-1===this.h&&this.m(),this.h}get v(){return-1===this.o&&this.m(),this.o}get D(){return-1===this.u&&this.m(),this.u}get j(){return-1===this.l&&this.m(),this.l}}const s=(t,s)=>Math.abs(t-s);class r{constructor(){this.N=[],this._=null}S(t){this.N.push(t),this._=null}L(t,r,e,i){for(let n=0;n<this.N.length;n++){const a=this.N[n];if(!(o=a.C,h=t.C,Math.min(s(o,h),s((o+.5)%1,(h+.5)%1))<r&&s(a.v,t.v)<e&&s(a.D,t.D)<i))return!1}var o,h;return!0}get O(){if(!this._){const{r:s,F:r,b:e}=this.N.reduce(((t,s)=>(t.r+=s.M,t.F+=s.g,t.b+=s.$,t)),{r:0,F:0,b:0}),i=this.N.reduce(((t,s)=>t+s.i),0);this._=new t(Math.round(s/this.N.length),Math.round(r/this.N.length),Math.round(e/this.N.length)),this._.i=i}return this._}}class e{constructor(t,s,r){this.k=[],this.C=t,this.v=s,this.D=r}S(t){const s=this.k.find((s=>s.L(t,this.C,this.v,this.D)));if(s)s.S(t);else{const s=new r;s.S(t),this.k.push(s)}}G(){return this.k.map((t=>t.O))}}class i{constructor(){this.i=0,this.P={}}S(s,r,e,i){return this.i++,this.P[s]?this.P[s].i++:this.P[s]=new t(r,e,i,s),this.P[s]}V(){return Object.keys(this.P).map((t=>this.P[t]))}H(){const t=this.V().reduce(((t,s)=>t.i>=s.i?t:s)).clone();return t.i=this.i,t}}class o{constructor(){this.i=0,this.P={}}V(){return Object.keys(this.P).map((t=>this.P[t]))}S(t,s,r){const e=t<<16|s<<8|r,i=(t>>4&15)<<8|(s>>4&15)<<4|r>>4&15;return this.i++,this.I(i).S(e,t,s,r)}I(t){return this.P[t]||(this.P[t]=new i),this.P[t]}q(s){const r=this.V().map((t=>t.H()));r.sort(((t,s)=>s.i-t.i));const e=[];for(;r.length;){const i=r.shift();r.filter((r=>t.distance(i,r)<s)).forEach((t=>{i.i+=t.i;const s=r.findIndex((s=>s===t));r.splice(s,1)})),e.push(i)}return e}}const h=(t,s,r,i,o)=>{const h=((t,s,r,i,o)=>{const h=new e(r,i,o);t.forEach((t=>h.S(t)));const n=h.G();return n.sort(((t,r)=>(r.j+.1)*(.9-r.i/s)-(t.j+.1)*(.9-t.i/s))),n})(t,s,r,i,o);return h.map((t=>((t,s)=>({hex:`#${"0".repeat(6-t.p.toString(16).length)}${t.p.toString(16)}`,red:t.M,green:t.g,blue:t.$,area:t.i/s,hue:t.C,saturation:t.v,lightness:t.D,intensity:t.j}))(t,s)))},n=(t,s={})=>{const[r,e,i,n,a,c]=(({pixels:t=64e3,distance:s=.22,colorValidator:r=((t,s,r,e)=>(null!=e?e:255)>250),hueDistance:e=.08333333333333333,saturationDistance:i=.2,lightnessDistance:o=.2,crossOrigin:h=null}={})=>{if("production"!==process.env.NODE_ENV){const n=(t,s,r=0,e=Number.MAX_VALUE)=>{if(Number(s)!==s)throw new Error(`${t} is not a valid number (${s})`);return s<r&&console.warn(`${t} can not be less than ${r} (it's ${s})`),s>e&&console.warn(`${t} can not be more than ${e} (it's ${s})`),Math.min(Math.max(s,r),e)},a=(t,s)=>{if(!s||"[object Function]"!=={}.toString.call(s))throw new Error(`${t} is not a function (${s})`);return s};return[((t,s,r=0,e=Number.MAX_SAFE_INTEGER)=>{if(!Number.isInteger(s))throw new Error(`${t} is not a valid number (${s})`);return s<r&&console.warn(`${t} can not be less than ${r} (it's ${s})`),s>e&&console.warn(`${t} can not be more than ${e} (it's ${s})`),Math.min(Math.max(s,r),e)})("pixels",t||0,1),n("distance",s,0,1),a("colorValidator",r),n("hueDistance",e,0,1),n("saturationDistance",i,0,1),n("lightnessDistance",o,0,1),h]}return[Math.max(t,1),Math.min(Math.max(s,0),1),r,Math.min(Math.max(e,0),1),Math.min(Math.max(i,0),1),Math.min(Math.max(o,0),1),h]})(s),{N:u,count:l}=(({data:t,width:s,height:r},e,i,h)=>{const n=new o,a=s&&r&&Math.floor(s*r/e)||1;let c=0;for(let o=0;o<t.length;o+=4*a){const s=t[o],r=t[o+1],e=t[o+2];h(s,r,e,t[o+3])?n.S(s,r,e):c++}return{N:n.q(i),count:n.i+c}})(t,r,e,i);return h(u,l,n,a,c)},a=(t,s)=>{if("production"!==process.env.NODE_ENV&&!t.data)throw new Error("Send imageData to extractColors");return new Promise((r=>{r(n(t,s))}))};exports.extractColorsFromImage=void 0,exports.extractColorsFromSrc=void 0,"production"!==process.env.NODE_ENV&&(exports.extractColorsFromImage=()=>{throw new Error("Can not use extractColorsFromImage for Node.js")},exports.extractColorsFromSrc=()=>{throw new Error("Can not use extractColorsFromSrc for Node.js")}),exports.default=a,exports.extractColors=a,exports.extractColorsFromImageData=n;
//# sourceMappingURL=extract-colors.node.cjs.js.map
